/* 
* The gaussian library of the A.S.P.I.C. 
 * Written and directed by FranÁois Lodier francois.lodier@gmail.com.
 *
 * Copyright (C) 2005  FranÁois Lodier
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */
#include "gaussianPolynome3D.h"
#include <string4Polynomes.h>

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Constructeur par d√©faut 
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussianPolynome3D::gaussianPolynome3D(void)
	: gaussian3D()
{
	;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Constructeur avec une gaussienne.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussianPolynome3D::gaussianPolynome3D(const gaussian3D & g)
	: gaussian3D(g)
{
	//clog << "Log : in gaussianPolynome3D::gaussianPolynome3D(const gaussian3D & g)" << endl;
	setPolynomeCoefficients(1);
	//clog << "Log : end gaussianPolynome3D::gaussianPolynome3D(const gaussian3D & g)" << endl;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Constructeur de copie.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussianPolynome3D::gaussianPolynome3D(const gaussianPolynome3D & gp)
{
	copy(gp);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Destructeur.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussianPolynome3D::~gaussianPolynome3D(void)
{
	;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode qui multiplie la gaussienne avec un monone centr√©.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussianPolynome3D gaussianPolynome3D::centerMonomeMultiply(const double & root , const int & dimension) const
{
	assert(dimension >= 0);
	assert(dimension < 3);
	gaussianPolynome3D shiftedPolynome(((const gaussian3D &)*this));
	shiftedPolynome.setPolynomeCoefficients(polynome3D::centerMonomeMultiply(root - getCenter()[dimension] , dimension));
	return shiftedPolynome;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode qui multiplie la gaussienne avec un monone centr√©.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussianPolynome3D gaussianPolynome3D::centerMonomeMultiply(const double & root , const int & dimension , const int & degree) const
{
	assert(dimension >= 0);
	assert(dimension < 3);
	assert(degree >= 0);

	int i;
	gaussianPolynome3D shiftedPolynome(*this);

	for(i=0 ; i < degree ; i++) {
		shiftedPolynome = shiftedPolynome.centerMonomeMultiply(root,dimension);
	}

	return shiftedPolynome;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode qui multiplie la gaussienne avec un monone centr√©.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussianPolynome3D gaussianPolynome3D::centerMonomeMultiply(const dpoint<3> & root , const ipoint<3> & degree) const
{
	assert(degree[0] >=0);
	assert(degree[1] >=0);
	assert(degree[2] >=0);

	gaussianPolynome3D shiftedPolynome(*this);

	for(int dim = 0; dim < 3 ; dim++) {
		shiftedPolynome = shiftedPolynome.centerMonomeMultiply(root[dim],dim,degree[dim]);	
	}
	
	return shiftedPolynome;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode qui multiplie la gaussienne avec un monone centr√©.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussianPolynome3D gaussianPolynome3D::centerMonomeMultiplyX(const double & root , const int & degree) const
{
	return centerMonomeMultiply(root,0,degree);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode qui multiplie la gaussienne avec un monone centr√©.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussianPolynome3D gaussianPolynome3D::centerMonomeMultiplyY(const double & root , const int & degree) const
{
	return centerMonomeMultiply(root,1,degree);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode qui multiplie la gaussienne avec un monone centr√©.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussianPolynome3D gaussianPolynome3D::centerMonomeMultiplyZ(const double & root , const int & degree) const
{
	return centerMonomeMultiply(root,2,degree);
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode qui change le centre de la gaussienne.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void gaussianPolynome3D::changeCenter(const dpoint<3> & center)
{
	polynome3D p(0) , shiftingPolynome;
	polynome basePolynomes[3];
	ipoint<3> i;
	int offset , dim;

	// Lorsque les deux centres sont identiques, il n'y a rien 
	// a faire. Donc on s'execute prestement.
	if(center == getCenter()) {
		return;
	}

	// On doit tout de mÍme passer par l'initialisation des polynomes.
	// de base.
	for(dim=0; dim<3 ; dim++){
		basePolynomes[dim].setPolynomeCoefficients(1);
	}

		
	for(i =begin() ; i!=end() ; i=next(i)) {

	
		for(dim = 0 ; dim < 3 ; dim++) {
			offset = i[dim] - basePolynomes[dim].getDegree();
			if( offset < 0) {
				basePolynomes[dim].setPolynomeCoefficients(1);
				offset  = i[dim];
			}
			if(offset > 0) {
				basePolynomes[dim] = basePolynomes[dim].centerMonomeMultiply(getCenter()[dim]-center[dim],offset);
			}
		
		}
		
		shiftingPolynome.setPolynomeCoefficients(basePolynomes[0],basePolynomes[1],basePolynomes[2]);	
		p += getPolynomeCoefficient(i) * shiftingPolynome;
	}

	setCenter(center);
	setPolynomeCoefficients(p);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode pour mettre le polynome √† 0.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void gaussianPolynome3D::clearPolynome(void)
{
	polynome3D::clear();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode de copie du polynome gaussien :
// - On "caste" l'argument en polynome de base et on copie la partie polynomiale.
// - On "caste" l'argument en gaussienne et on copie la gaussienne.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void gaussianPolynome3D::copy(const gaussianPolynome3D & gp)
{
	polynome3D::copy(gp);
	gaussian3D::copy(gp);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode pour faire la d√©rivation.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussianPolynome3D gaussianPolynome3D::derivate(int dim) const
{
	assert(dim >= 0);
	assert(dim < 3);

	gaussianPolynome3D dgp((const gaussian3D &)(*this));
	((polynome3D &)(dgp)) = getPolynomeCoefficients() * (gaussian3D::derivate(dim));	
	((polynome3D &)(dgp)) += getPolynomeCoefficients().derivate(dim);
	return dgp;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode pour faire la d√©rivation.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussianPolynome3D gaussianPolynome3D::derivateX(void) const
{
	return derivate(0);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode pour faire la d√©rivation.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussianPolynome3D gaussianPolynome3D::derivateY(void) const
{
	return derivate(1);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode pour faire la d√©rivation.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussianPolynome3D gaussianPolynome3D::derivateZ(void) const
{
	return derivate(2);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode pour faire la d√©rivation.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussianPolynome3D gaussianPolynome3D::derivate(ipoint<3>  degre) const
{
	gaussianPolynome3D tmp (*this);

	for(int dimension = 0 ; dimension < 3 ; dimension ++)  {
		while(degre[dimension] > 0) {
			tmp = tmp.derivate(dimension);
			degre[dimension]--;
		}
	}

	return tmp;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Method EVAL
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double gaussianPolynome3D::eval(const dpoint<3> & x) const
{
	double value;
	value = gaussian3D::eval(x);
	value *= polynome3D::eval(x-getCenter());
	return value;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// - M√©thode pour √©crire les fonctions de base du polynome.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const string gaussianPolynome3D::getBaseString(const ipoint<3> & i) const
{
	return monome3D2string(i,getCenter());
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode pour GET pour acc√©der au polynome qui se trouve devant 
// la gaussienne.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const polynome3D & gaussianPolynome3D::getPolynomeCoefficients(void) const
{
	return ((const polynome3D & )(*this));
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode pour fixer le coefficient d'un polynome.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double gaussianPolynome3D::getPolynomeCoefficient(const ipoint<3> &  deg) const
{
	assert(deg[0] >=0);
	assert(deg[1] >=0);
	assert(deg[2] >=0);

	return polynome3D::getData(deg);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode pour fixer le coefficient d'un polynome.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double gaussianPolynome3D::getPolynomeCoefficient(const int & degreeX , const int & degreeY , const int & degreeZ) const
{
	assert(degreeX >=0);
	assert(degreeY >=0);
	assert(degreeZ >=0);

	return polynome3D::getData(degreeX,degreeY,degreeZ);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode pour connaitre les plus haut degr√©s du polynome.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ipoint<3> gaussianPolynome3D::getPolynomeUniformMax4Degree(void) const
{
	return polynome3D::getUniformMax4Degree();
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode pour calculer l'int√©grale sur R^3 du polynome gaussien.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double gaussianPolynome3D::integral(void) const
{
	double overlap = 0;
	ipoint<3> degre;
	containor3D<double> baseIntegrals;

	degre = getUniformMax4Degree();
	gaussian3D::integrals(degre , baseIntegrals);

	for(degre = begin() ; degre != end() ; degre = next(degre) ) {

		if( (degre[0] % 2) ||  (degre[1] % 2) || (degre[2] % 2)) {
			continue;
		}
		overlap += getPolynomeCoefficient(degre) * baseIntegrals(degre);
	}
	
	return overlap;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode pour faire la multiplication de deux polynomes gaussiens.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void gaussianPolynome3D::multiply(gaussianPolynome3D gp_a , gaussianPolynome3D gp_b)
{
	gaussian3D::multiply(gp_a,gp_b);

	if(gp_a.getCenter() != gp_b.getCenter()) {
		gp_a.changeCenter(getCenter());
		gp_b.changeCenter(getCenter());
	}

	polynome3D::multiply(gp_a,gp_b);
}

////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode pour faire la multiplication de deux polynomes gaussiens.
////////////////////////////////////////////////////////////////////////////////////////////
void gaussianPolynome3D::multiply(const gaussianPolynome3D & gaussianPoly)
{
	gaussianPolynome3D tmp(*this);
	multiply(tmp,gaussianPoly);
}

////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode pour faire la multiplication de deux polynomes gaussiens.
////////////////////////////////////////////////////////////////////////////////////////////
void gaussianPolynome3D::multiply(const gaussianPolynome3D & gaussianPoly , const double & scalar)
{
	copy(gaussianPoly);
	multiply(scalar);
}

////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode pour faire la multiplication de deux polynomes gaussiens.
////////////////////////////////////////////////////////////////////////////////////////////
void gaussianPolynome3D::multiply(const double & scalar)
{
	gaussian3D::multiply(scalar);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Operateur *.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussianPolynome3D gaussianPolynome3D::operator*(const gaussianPolynome3D & gp) const
{
	gaussianPolynome3D tmp;
	tmp.multiply(*this,gp);
	return tmp;
}

////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode pour faire la multiplication de deux polynomes gaussiens.
////////////////////////////////////////////////////////////////////////////////////////////
gaussianPolynome3D gaussianPolynome3D::operator* (const double & scalar) const
{
	gaussianPolynome3D tmp;
	tmp.multiply(*this,scalar);
	return tmp;
}

////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode pour faire la multiplication unaire de deux polynomes gaussiens.
////////////////////////////////////////////////////////////////////////////////////////////
gaussianPolynome3D & gaussianPolynome3D::operator*= (const gaussianPolynome3D & gaussianPoly)
{
	multiply(gaussianPoly);
	return *this;
}

////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode pour faire la multiplication unaire de deux polynomes gaussiens.
////////////////////////////////////////////////////////////////////////////////////////////
gaussianPolynome3D & gaussianPolynome3D::operator*= (const double & scalar)
{
	multiply(scalar);
	return *this;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Op√©rateur d'affectation avec une gaussienne polynome.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussianPolynome3D & gaussianPolynome3D::operator =(const gaussianPolynome3D & gaussianPoly)
{
	copy(gaussianPoly);
	return *this;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Op√©rateur d'affectation avec une gaussienne polynome.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussianPolynome3D & gaussianPolynome3D::operator =(const gaussian3D & g)
{
	gaussian3D::copy(g);
	setPolynomeCoefficients(1);
	return *this;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode pour acc√©der aux degr√© pr√©sents dans le polynome.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ipoint<3> gaussianPolynome3D::polynomeEnd(void) const
{
	return polynome3D::end();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode pour acc√©der aux degr√© pr√©sents dans le polynome.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ipoint<3> gaussianPolynome3D::polynomeBegin(void) const
{
	return polynome3D::begin();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode pour acc√©der aux degr√© pr√©sents dans le polynome.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ipoint<3> gaussianPolynome3D::polynomeNext(const ipoint<3> & degree) const
{
	return polynome3D::next(degree);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode pour fixer le coefficient d'un polynome.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void gaussianPolynome3D::setPolynomeCoefficient(const ipoint<3> &  degree ,const double & value)
{
	assert(degree[0] >=0);
	assert(degree[1] >=0);
	assert(degree[2] >=0);

	polynome3D::setData(degree,value);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode pour modifier la valeur d'un coefficient du polynome.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void gaussianPolynome3D::setPolynomeCoefficient(const int & degreeX , const int & degreeY , const int & degreeZ ,const double & value)
{
	assert(degreeX >=0);
	assert(degreeY >=0);
	assert(degreeZ >=0);

	polynome3D::setData(degreeX,degreeY,degreeZ,value);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode pour fixer le polynome avec une simple valeur r√©elle.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void gaussianPolynome3D::setPolynomeCoefficients(const double & value)
{
	polynome3D::setPolynomeCoefficients(value);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode pour fixer le polynome avec une simple valeur r√©elle.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void gaussianPolynome3D::setPolynomeCoefficients(const polynome3D & polynomeCoefficients)
{
	polynome3D::setPolynomeCoefficients(polynomeCoefficients);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode qui √©crit le polynome gaussien dans un flux.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void gaussianPolynome3D::write(ostream & outStream) const
{
	gaussian3D::write(outStream);
	outStream << "*( " ;	
	polynome3D::write(outStream);
	outStream << " )" ;	
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Op√©rateur d'√©criture dans un flux.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ostream & operator<<( ostream & outStream , const gaussianPolynome3D & gp)
{
	gp.write(outStream);
	return outStream;
}
