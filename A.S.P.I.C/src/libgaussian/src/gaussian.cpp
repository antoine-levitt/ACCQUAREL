/* 
* The gaussian library of the A.S.P.I.C. 
 * Written and directed by FranÁois Lodier francois.lodier@gmail.com.
 *
 * Copyright (C) 2005  FranÁois Lodier
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */
#include <assert.h>
#include "error_function.h"
#include "gaussian.h"
#include "gaussianPolynome.h"
#include <iomanip>
#include <iostream>
#define _USE_MATH_DEFINES 
#include <math.h>
#include <string>
#include <string4Polynomes.h>
using namespace std;

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Le constructeur par d√©faut.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussian::gaussian(void)
	: Center(0),
	Coefficient(1),
	Exponent(1)
{
	;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Le constructeur avec les valeurs.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussian::gaussian(const double & center , const double & coefficient , const double & exponent)
	: Center(0),
	Coefficient(1),
	Exponent(1)
{
	setCenter(center);
	setCoefficient(coefficient);
	setExponent(exponent);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Le constructeurs de copie.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussian::gaussian(const gaussian & g)
	: Center(0),
	Coefficient(1),
	Exponent(1)
{
	copy(g);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Le destructeur ne fait rien.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussian::~gaussian(void)
{
	;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Comparaison de deux gaussiennes :
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double gaussian::compare(const gaussian & ga , const gaussian & gb)
{
	// Les erreurs sur chaque parametre.
	double errorCenter      = fabs(ga.getCenter()      - gb.getCenter()     );
	double errorCoefficient = fabs(ga.getCoefficient() - gb.getCoefficient());
	double errorExponent    = fabs(ga.getExponent()    - gb.getExponent()   );
	double error_max;

	//On va afficher les diff√©rences :
	clog << "Log : in double gaussian::compare(const gaussian & ga , const gaussian & gb)" << endl;
	clog << "Log : Centers Error      : " << setprecision(10) <<  errorCenter      << endl;
	clog << "Log : Coefficients Error : " << setprecision(10) <<  errorCoefficient << endl;
	clog << "Log : Exponents Error    : " << setprecision(10) <<  errorExponent    << endl;

	// Ensuite on renvoie l'erreur maximale :
	error_max = max(errorCenter,errorCoefficient);
	error_max = max(error_max,errorExponent);
	
	return error_max;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Calcul du centre de la gaussienne produit.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double gaussian:: computeCenter(const gaussian & ga , const gaussian & gb)
{
	return (ga.getCenter() * ga.getExponent() + gb.getCenter() * gb.getExponent()) / (ga.getExponent() + gb.getExponent());
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Calcul du centre de la gaussienne produit.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double gaussian::computeCoefficient(const gaussian & ga , const gaussian & gb)
{
	double coefficient = pow(ga.getCenter() - gb.getCenter(), 2);
	coefficient = ga.getCoefficient() * gb.getCoefficient() * exp (-(ga.getExponent() * gb.getExponent() * coefficient ) / (ga.getExponent() + gb.getExponent() ) ) ;
	return coefficient;	
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Calcul de l'exposant de la gaussienne produit.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double gaussian::computeExponent(const gaussian & ga , const gaussian & gb)
{
	return ga.getExponent() + gb.getExponent();
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode pour copier une gaussienn dans l'objet courrant.
//
// Cette m√©thode existe car elle est utilis√© par le constructeur 
// de copie et l'operateur d'affectation. Cela √©vite d'avoir √† 
// r√©√©crire deux fois la meme chose.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void gaussian::copy(const gaussian & g)
{
	setCenter(g.getCenter());
	setCoefficient(g.getCoefficient());
	setExponent(g.getExponent());
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode pour faire la d√©rivation.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussianPolynome gaussian::derivate(void) const
{
	gaussianPolynome dgp(*this);
	dgp.clearPolynome();
	dgp.setPolynomeCoefficient(1,-2 * getExponent());
	return dgp;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode pour faire la division unaire d'une gaussienne et d'un scalaire
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void gaussian::divide(const double & scalar)
{
	assert(scalar != 0);
	double coefficient = getCoefficient() / scalar ;
	setCoefficient(coefficient);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode pour faire la division d'une gaussienne et d'un scalaire
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void gaussian::divide(const gaussian & g , const double & scalar)
{
	assert(scalar != 0);
	copy(g);
	divide(scalar);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode pour acc√©der au centre de la gaussienne.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const double & gaussian::getCenter(void) const
{
	return Center;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode pour acc√©der au coefficient de la gaussienne.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const double & gaussian::getCoefficient(void) const
{
	return Coefficient;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode pour acc√©der √† l'exposant de la gaussienne
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const double & gaussian::getExponent(void) const
{
	return Exponent;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode pour calculer l'int√©grale sur R de la gaussienne.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double gaussian::integral(void) const
{
	double value = sqrt(M_PI);
	value /= sqrt(getExponent());
	value *= getCoefficient();	
	return value;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode pour plein d'int√©grales sur R de la gaussienne.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void gaussian::integrals(const int & d_max , containor<double> & overlaps) const
{
	assert(d_max >= 0);

	overlaps.setSizes(d_max+1);

	overlaps[0] = integral();

	if(d_max > 0) {
		overlaps[1] = 0;
	}

	double exponent= getExponent();

	for(int i=2 ; i<= d_max ;i++) {
		if(i%2) {
			overlaps[i] = 0;
		} else {
			overlaps[i] = (i-1)* overlaps[i-2] / (2 * exponent);
		}
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode pour plein d'int√©grales sur R de la gaussienne.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void gaussian::integrals_odd(const int & d_max , containor<double> & overlaps) const
{
	assert(d_max >= 0);
	
	int size = d_max/2 + 1;
	double sqrtCoefficient = sqrt(getCoefficient());
	
	overlaps.setSizes(size);

	overlaps[0] = integral();

	for(int i=1 ; i < size ;i++) {
			overlaps[i] =  (2*i -1) * overlaps[i-1] / (2 * sqrtCoefficient);
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode pour faire la multiplication de deux gaussiennes
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void gaussian::multiply(const gaussian & ga , const gaussian & gb)
{
	setCenter(computeCenter(ga,gb));
	setCoefficient(computeCoefficient(ga,gb));
	setExponent(computeExponent(ga,gb));
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode pour faire la multiplication uanire de deux gaussiennes
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void gaussian::multiply(const gaussian & g)
{
	gaussian g_tmp;
	g_tmp.multiply(*this,g);
	copy(g_tmp);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode pour faire la multiplication d'une gaussienne et d'un scalaire
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void gaussian::multiply(const gaussian & g , const double & scalar)
{
	copy(g);
	multiply(scalar);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode pour faire la multiplication unaire d'une gaussienne et d'un scalaire
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void gaussian::multiply(const double & scalar)
{
	double coefficient = scalar * getCoefficient();
	setCoefficient(coefficient);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Op√©rateur d'affectation :
// M√©thode qui permet d'utiliser le signe = pour copier deux gaussiennes.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussian & gaussian::operator=(const gaussian & g)
{
	copy(g);
	return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Op√©rateur pour faire la multiplication de deux gaussiennes
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussian gaussian::operator*(const gaussian & g) const
{
	gaussian tmp;
	tmp.multiply(*this,g);
	return tmp;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Op√©rateur pour faire la multiplication uanire de deux gaussiennes
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussian & gaussian::operator*=(const gaussian & g) 
{
	multiply(g);
	return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Op√©rateur pour faire la multiplication d'une gaussienne et d'un scalaire
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussian gaussian::operator*(const double & scalar) const
{
	gaussian tmp;
	tmp.multiply(*this,scalar);
	return tmp;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Op√©rateur pour faire la multiplication unaire d'une gaussienne et d'un scalaire
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussian & gaussian::operator*=(const double & scalar) 
{
	multiply(scalar);
	return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Op√©rateur externe pour faire la multiplication d'une gaussienne et d'un scalaire
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussian operator*(const double & scalar , const gaussian & g)
{
	return g*scalar;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// OpÈrateur pour faire la division unaire d'une gaussienne et d'un scalaire
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussian & gaussian::operator/=(const double & scalar) 
{
	assert(scalar != 0);
	divide(scalar);
	return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// OpÈrateur pour faire la division d'une gaussienne et d'un scalaire
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
gaussian gaussian::operator/(const double & scalar) const
{
	assert(scalar != 0);
	gaussian tmp;
	tmp.divide(*this,scalar);
	return tmp;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode qui calcule la valeur de la primitive de la gaussienne.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double gaussian::primitive(const double & x) const
{
	double value = getCoefficient() * sqrt(M_PI) / 2.;
	double sqrtExponent = sqrt(getExponent());
	value *= error_function(sqrtExponent * (x - getCenter())) + error_function( sqrtExponent * getCenter());
	value /= sqrtExponent;
	return value;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// M√©thode pour calculer plein de primitives.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void gaussian::primitives(const double & x , const int & d_max , containor<double> & primitives) const
{
	// 0 - v√©rification et mise √† la taille.
	assert(d_max >= 0);
	int size = d_max + 1;
	primitives.setSizes(size);

	// 1 - initialisation.
	primitives[0] = primitive(x);

	// On regarde si il reste du travail ?
	if(d_max == 0) {
		return;
	}

	double integrationPart1 = - exp(-getExponent() * pow(x-getCenter(),2)) / ( 2 * getExponent());
	double integrationPart2 = exp(-getExponent() * pow(-getCenter(),2)) / ( 2 * getExponent());
	primitives[1] = integrationPart1 + integrationPart2;

	// 2 - r√©currence.
	for(int i=2; i < size ; i++) {
		integrationPart1 *=  x-getCenter();
		integrationPart2 *= -getCenter();
		primitives[i] = integrationPart1 + integrationPart2 + (i-1) * primitives[i-2] / ( 2 * getExponent());
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Methode pour donner une valeur au centre de la gaussienne.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void gaussian::setCenter(const double & center)
{
	Center = center;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Methode pour donner une valeur au coefficient de la gaussienne.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void gaussian::setCoefficient(const double & coefficient)
{
	Coefficient = coefficient;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Methode pour donner une valeur √† l'exposant de la gaussienne.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void gaussian::setExponent(const double & exponent)
{
	assert(exponent > 0);
	Exponent = exponent;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Ecriture de la gaussienne dans un flux.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void gaussian::write(ostream & outStream) const
{
	if(getCoefficient() != 1 ) {
		outStream << getCoefficient() ;
		outStream << " * ";
	}

	outStream << "exp( -";
	
	if(getExponent() != 1) {
 		outStream << getExponent() ;
		outStream << " * "	;
	}
	
	outStream << monome2string("x" , getCenter() , 2);
	outStream << " )";
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Ecriture de la gaussienne dans un flux.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ostream & operator << (ostream & outStream , const gaussian & g)
{
	g.write(outStream);
	return outStream;
}

